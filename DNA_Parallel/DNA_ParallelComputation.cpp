/* ============================================================================ Name        : DNA_ParallelComputation.cpp Author      : Douglas Version     : Copyright   : Your copyright notice Description : DNA parallel ============================================================================ */#include <math.h> #include "mpi.h" #include <iostream>#include <stdlib.h>#include "DNAStrandHelper.h"#include <string>#include <sstream>using namespace std; // Function for checking the inputbool is_number( string& s);bool checkForDouble(string & s);int main(int argc, char *argv[]) {	// Default values..	int length = 50;	int dataSize = 100;	int centroidNum = 4;	double threshold = 0.001;	int iteration = 2000;	string fileName = "output";	// Initializing the helper	DNAStrandHelper *helper = new DNAStrandHelper();	// Start the MPI	helper->init_MPI();	// User input is only taken from RANK ==0	if(helper->MPI_getRank() == 0){		string enter;		cout << "Starting the DNA Serial Clustering" << endl;		cout << "Enter in the length of the DNA strand : " ;		cin >> enter;		if(!is_number(enter)){			cout << "Number value is needed. Please try again." << endl;			return 0;		} else {			length = atoi(enter.c_str());		}		cout << "Enter in the size for the DATA :  " ;		cin >> enter;		if(!is_number(enter)){			cout << "Number value is needed. Please try again." << endl;			return 0;		} else {			dataSize = atoi(enter.c_str());		}		cout << "Enter in the Centroid number : " ;		cin >> enter;		if(!is_number(enter)){			cout << "Number value is needed. Please try again." << endl;			return 0;		} else {			centroidNum = atof(enter.c_str());		}		cout << "Enter in the threshold : " ;		cin >> enter;		if(!checkForDouble(enter)){			cout << "Number value is needed. Please try again." << endl;			return 0;		} else {			threshold = atof(enter.c_str());		}		cout << "Enter in the max iteration : ";		cin >> enter;		if(!is_number(enter)){			cout << "Number value is needed. Please try again." << endl;			return 0;		} else {			iteration = atoi(enter.c_str());		}		cout << "Enter in the output fileName : ";		cin >> enter;		fileName = enter;	}	// The parameters to all childs.	helper->setParams(length,dataSize,centroidNum, threshold, iteration );	char **data = NULL; // where the data lives	int *cluster = NULL; // where the cluster classification lives	char **centriods = NULL;	// RANK ==0 will run the generation of the data	if(helper->MPI_getRank() == 0){		// Initializing the arrays.		data = new char*[dataSize]; // where the data lives		cluster = new int[dataSize]; // where the cluster classification lives		cout << "Generating Data"<<endl;		for(int i = 0; i < dataSize ; i++){			char* oneStrand = helper->getRamdomDNAStrand();			data[i]=oneStrand;		}		cout << "Done." << endl;		// Picking the centroids		centriods = helper->pickCentriods(data);	}	time_t start, end;	// Starting the timer.	if(helper->MPI_getRank() == 0){		time (&start); //useful call		cout << "Starting timer for RANK = 0" << endl;	}	// Finding the clusters	helper->MPI_findCluster(data, centriods, cluster);	// printing out the results	if(helper->MPI_getRank() == 0){		time (&end);		cout.precision(15);		double diff = difftime(end,start);//this will give you time spent between those two calls.		cout << "TIME PAST in Seconds = " << fixed <<diff<< endl;		cout << "Printing to file" << endl;		helper->printAllWithCluster(data,cluster, fileName);		cout << "Done printing." << endl;	}	// deleting all allocation	if(data != NULL){		for(int i = 0; i < dataSize ; i++){				delete[] data[i];		}		delete[] data;	}	if(centriods != NULL){		for(int i = 0; i < centroidNum; i++){				delete[] centriods[i];		}			delete[] centriods;	}	if( cluster != NULL){		delete[] cluster;	}	helper->final_MPI();	return 0;}bool is_number( string& s){    string::const_iterator it = s.begin();    while (it != s.end() && std::isdigit(*it)) ++it;    return !s.empty() && it == s.end();}bool checkForDouble(string & s) {  istringstream ss(s);  double d;  return (ss >> d) && (ss >> std::ws).eof();}